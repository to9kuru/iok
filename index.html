<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>弱き者から死んでいく</title>

<style>
    body {
        margin: 0;
        overflow: hidden;
        background: #050505;
        font-family: "Yu Mincho", serif;
        user-select: none;
        -webkit-user-select: none;
    }
    canvas {
        display: block;
        touch-action: none;
    }
    #ui, #game-over-screen {
        position: absolute;
        inset: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        color: #fff;
        z-index: 10;
        pointer-events: none;
    }
    h1 {
        font-size: 5rem;
        letter-spacing: 0.5rem;
        text-shadow: 0 0 20px #0ff;
        margin: 0;
    }
    p { font-size: 1.4rem; color: #aaa; margin-top: 10px; text-align: center; }
    
    /* スコア表示エリア */
    .hud {
        position: absolute;
        left: 20px;
        color: #0ff;
        font-size: 1.5rem;
        font-family: monospace;
        z-index: 5;
        text-shadow: 0 0 5px #0ff;
        pointer-events: none;
    }
    #score-display { top: 20px; }
    #death-display { top: 50px; color: #ff3333; text-shadow: 0 0 5px #f00; }

    #game-over-screen {
        display: none;
        background: rgba(0,0,0,0.85);
        z-index: 20;
        pointer-events: auto;
    }
    button {
        margin-top: 40px;
        padding: 15px 50px;
        font-size: 1.5rem;
        background: transparent;
        border: 2px solid #0ff;
        color: #0ff;
        cursor: pointer;
        transition: 0.2s;
        text-transform: uppercase;
        letter-spacing: 2px;
    }
    button:hover {
        background: #0ff;
        color: #000;
        box-shadow: 0 0 20px #0ff;
    }
</style>
</head>

<body>

<div id="score-display" class="hud">TIME: 0.00</div>
<div id="death-display" class="hud">DEATH: 0</div>

<div id="ui">
    <h2>弱き者から死んでいく</h2>
    <p>強き者となるため、レッツクリック！</p>
</div>

<div id="game-over-screen">
    <h1 style="color:#ff3333; text-shadow: 0 0 20px #f00;">無念</h1>
    <p id="final-score" style="color:white; line-height: 1.8;"></p>
    <button onclick="resetGame()">RETRY</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const ui = document.getElementById("ui");
const scoreDisplay = document.getElementById("score-display");
const deathDisplay = document.getElementById("death-display");
const gameOverScreen = document.getElementById("game-over-screen");
const finalScore = document.getElementById("final-score");

/* === 難易度調整用設定 === */
// この画面幅(px)を基準(倍率1.0)とします。
// 例: 600に設定すると、画面幅1200のPCでは球が2倍の大きさになり、
// 画面幅300のスマホでは0.5倍の大きさになります。これで難易度感を統一します。
const BASE_SCREEN_WIDTH = 600; 
let gameScale = 1; // 現在のスケール倍率

let w, h;
let isPlaying = false;
let isInputActive = false;
let animationId;
let startTime;
let deathCount = 0; 

// Game State
const player = {
    x: 0, y: 0,
    targetX: 0, targetY: 0,
    baseRadius: 14, // 基準の半径
    radius: 14,     // 実際の半径（リサイズ時に計算）
    baseSpeed: 7,   // 基準のスピード
    speed: 7,       // 実際のスピード
    moving: false,
    color: "#00ffff"
};

let enemies = [];
let particles = [];

/* ===== SETUP ===== */
function resize() {
    w = canvas.width = innerWidth;
    h = canvas.height = innerHeight;

    // 画面幅に応じたスケール値を計算
    gameScale = w / BASE_SCREEN_WIDTH;
    
    // スマホなどで小さくなりすぎないよう、最低倍率を0.5に制限（お好みで調整可）
    gameScale = Math.max(gameScale, 0.5);

    // プレイヤーのサイズと速度を更新
    player.radius = player.baseRadius * gameScale;
    player.speed = player.baseSpeed * gameScale;

    if(!isPlaying) {
        player.x = player.targetX = w / 2;
        player.y = player.targetY = h / 2;
        drawIdle();
    }
}
window.addEventListener("resize", resize);

/* ===== CONTROLS ===== */
canvas.addEventListener("pointerdown", e => {
    if (gameOverScreen.style.display === 'flex') return;
    
    if (!isPlaying) {
        startGame();
    }
    isInputActive = true;
    player.moving = true;
    setTarget(e.clientX, e.clientY);
});

canvas.addEventListener("pointermove", e => {
    if (!isPlaying || !isInputActive) return;
    setTarget(e.clientX, e.clientY);
});

canvas.addEventListener("pointerup", () => {
    isInputActive = false;
    player.moving = false;
});

function setTarget(x, y) {
    player.targetX = x;
    player.targetY = y;
}

/* ===== CORE LOGIC ===== */
function startGame() {
    isPlaying = true;
    ui.style.display = "none";
    gameOverScreen.style.display = "none";
    enemies = [];
    particles = [];
    startTime = Date.now();
    
    deathCount = 0;
    deathDisplay.textContent = `DEATH: ${deathCount}`;

    player.x = w/2; 
    player.y = h/2;
    player.targetX = w/2; 
    player.targetY = h/2;
    loop();
}

function resetGame() {
    gameOverScreen.style.display = "none";
    ui.style.display = "flex";
    isPlaying = false;
    resize();
}

/* ===== ENEMIES ===== */
function spawnEnemy(difficulty) {
    // 敵の基本サイズを設定し、スケール倍率を掛ける
    const baseR = 10 + Math.random() * 12;
    const r = baseR * gameScale; 
    
    // 出現位置のオフセットもスケールさせる
    const offset = 50 * gameScale; 
    
    const side = Math.floor(Math.random() * 4);
    let x, y;

    if (side === 0) { x = Math.random() * w; y = -offset; }       // Top
    if (side === 1) { x = w + offset; y = Math.random() * h; }    // Right
    if (side === 2) { x = Math.random() * w; y = h + offset; }    // Bottom
    if (side === 3) { x = -offset; y = Math.random() * h; }       // Left

    const angle = Math.atan2(player.y - y, player.x - x);
    
    // 敵のスピードもスケールさせる
    const baseSpeed = 3 + (difficulty * 0.5) + (Math.random() * 2);
    const speed = baseSpeed * gameScale;

    enemies.push({
        x, y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        r
    });
}

/* ===== PARTICLES (EXPLOSION) ===== */
function createExplosion(x, y, color) {
    for (let i = 0; i < 20; i++) {
        const angle = Math.random() * Math.PI * 2;
        
        // パーティクルの飛び散る速度もスケール
        const baseSpeed = Math.random() * 5 + 2;
        const speed = baseSpeed * gameScale;

        particles.push({
            x: x, y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1.0,
            color: color
        });
    }
}

/* ===== GAME OVER ===== */
function gameOver() {
    isPlaying = false;
    isInputActive = false;
    createExplosion(player.x, player.y, player.color);
    
    renderFrame(); 

    setTimeout(() => {
        cancelAnimationFrame(animationId);
        const timeStr = ((Date.now() - startTime) / 1000).toFixed(2);
        
        finalScore.innerHTML = `生存記録: ${timeStr}秒<br>あなたより弱き者: ${deathCount}体`;
        
        gameOverScreen.style.display = "flex";
    }, 500);
}

/* ===== LOOP ===== */
function loop() {
    if (!isPlaying) return;
    renderFrame();
    animationId = requestAnimationFrame(loop);
}

function renderFrame() {
    ctx.fillStyle = "rgba(5, 5, 5, 0.3)";
    ctx.fillRect(0, 0, w, h);

    const currentTime = (Date.now() - startTime) / 1000;
    const difficulty = 1 + Math.floor(currentTime / 10);
    scoreDisplay.textContent = `TIME: ${currentTime.toFixed(2)}`;

    // 1. Update Player
    if (player.moving) {
        const dx = player.targetX - player.x;
        const dy = player.targetY - player.y;
        const dist = Math.hypot(dx, dy);
        
        // 判定の許容値も少しスケール
        if (dist > 1 * gameScale) {
            const step = Math.min(player.speed, dist);
            player.x += (dx / dist) * step;
            player.y += (dy / dist) * step;
        }
    }

    // Draw Player
    ctx.shadowBlur = 20 * gameScale; // 光彩もスケール
    ctx.shadowColor = player.color;
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
    ctx.fillStyle = player.color;
    ctx.fill();
    ctx.shadowBlur = 0;

    // 2. Spawn Enemies
    if (Math.random() < 0.05 + (difficulty * 0.01)) {
        spawnEnemy(difficulty);
    }

    // 3. Update Enemies
    for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        e.x += e.vx;
        e.y += e.vy;

        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
        ctx.fillStyle = "#ff3333";
        ctx.fill();

        // Collision Check
        const dist = Math.hypot(player.x - e.x, player.y - e.y);
        if (isPlaying && dist < player.radius + e.r) {
            gameOver();
            return;
        }

        // Garbage Collection
        const margin = 100 * gameScale;
        if (e.x < -margin || e.x > w + margin || e.y < -margin || e.y > h + margin) {
            enemies.splice(i, 1);
            deathCount++;
            deathDisplay.textContent = `DEATH: ${deathCount}`;
        }
    }

    // 4. Update Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.05;
        
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        // パーティクルのサイズもスケール(基本3px)
        ctx.arc(p.x, p.y, 3 * gameScale, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;

        if (p.life <= 0) particles.splice(i, 1);
    }
}

function drawIdle() {
    ctx.fillStyle = "#050505";
    ctx.fillRect(0, 0, w, h);
    
    ctx.shadowBlur = 20 * gameScale;
    ctx.shadowColor = player.color;
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
    ctx.fillStyle = player.color;
    ctx.fill();
    ctx.shadowBlur = 0;
}

// 初期化実行
resize();
</script>
</body>
</html>
