<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>弱いやつから死んでいく</title>

<style>
body {
    margin: 0;
    overflow: hidden;
    background: #050505;
    font-family: "Yu Mincho", serif;
    user-select: none;
}
canvas {
    display: block;
    cursor: crosshair;
    touch-action: none;
}
#ui {
    position: absolute;
    inset: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    color: #fff;
    z-index: 10;
    pointer-events: none;
}
h1 {
    font-size: 4rem;
    letter-spacing: 0.5rem;
    text-shadow: 0 0 10px #0ff;
}
p { font-size: 1.4rem; color: #aaa; }
#score-display {
    position: absolute;
    top: 20px;
    left: 20px;
    color: #0ff;
    font-size: 1.6rem;
    font-family: monospace;
}
#game-over-screen {
    display: none;
    position: absolute;
    inset: 0;
    background: rgba(0,0,0,0.85);
    z-index: 20;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    color: #fff;
}
button {
    margin-top: 30px;
    padding: 15px 40px;
    font-size: 1.4rem;
    background: transparent;
    border: 2px solid #0ff;
    color: #0ff;
    cursor: pointer;
}
button:hover {
    background: #0ff;
    color: #000;
}
</style>
</head>

<body>

<div id="score-display">生存時間: 0.00秒</div>

<div id="ui">
    <h1>IOK</h1>
    <p>画面を押して開始</p>
</div>

<div id="game-over-screen">
    <h1 style="color:#ff3333;font-size:4rem;">無念</h1>
    <p id="final-score"></p>
    <button onclick="resetGame()">再挑戦</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const ui = document.getElementById("ui");
const scoreDisplay = document.getElementById("score-display");
const gameOverScreen = document.getElementById("game-over-screen");
const finalScore = document.getElementById("final-score");

let w, h;
let isPlaying = false;
let isInputActive = false;
let canRestart = true;
let startTime;
let animationId;

const player = {
    x: 0,
    y: 0,
    targetX: 0,
    targetY: 0,
    radius: 14,
    speed: 6,
    moving: false,
    color: "#00ffff"
};

let enemies = [];

/* ===== 初期化 ===== */
function resize() {
    w = canvas.width = innerWidth;
    h = canvas.height = innerHeight;
    player.x = player.targetX = w / 2;
    player.y = player.targetY = h / 2;
    drawIdle();
}
addEventListener("resize", resize);

/* ===== 入力 ===== */
canvas.addEventListener("pointerdown", e => {
    if (!canRestart) return;
    isInputActive = true;
    player.moving = true;
    setTarget(e.clientX, e.clientY);
});

canvas.addEventListener("pointermove", e => {
    if (!isInputActive || !player.moving) return;
    setTarget(e.clientX, e.clientY);
});

canvas.addEventListener("pointerup", stopInput);
canvas.addEventListener("pointercancel", stopInput);

function stopInput() {
    isInputActive = false;
    player.moving = false;
    player.targetX = player.x;
    player.targetY = player.y;
    if (!isPlaying) canRestart = true;
}

/* ===== ターゲット設定 ===== */
function setTarget(x, y) {
    if (!isPlaying) startGame();
    player.targetX = x;
    player.targetY = y;
}

/* ===== ゲーム制御 ===== */
function startGame() {
    isPlaying = true;
    canRestart = false;
    ui.style.display = "none";
    gameOverScreen.style.display = "none";
    enemies = [];
    startTime = Date.now();
    loop();
}

function resetGame() {
    isPlaying = false;
    canRestart = true;
    ui.style.display = "flex";
    gameOverScreen.style.display = "none";
    drawIdle();
}

/* ===== 敵 ===== */
function spawnEnemy(diff) {
    const r = 12 + Math.random() * 10;
    const side = Math.floor(Math.random() * 4);
    let x, y;
    if (side === 0) { x = Math.random() * w; y = -40; }
    if (side === 1) { x = w + 40; y = Math.random() * h; }
    if (side === 2) { x = Math.random() * w; y = h + 40; }
    if (side === 3) { x = -40; y = Math.random() * h; }
    const angle = Math.atan2(player.y - y, player.x - x);
    const speed = 3 + diff * 0.7;
    enemies.push({
        x, y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        r
    });
}

/* ===== 自機移動 ===== */
function movePlayer() {
    if (!player.moving) return;
    const dx = player.targetX - player.x;
    const dy = player.targetY - player.y;
    const dist = Math.hypot(dx, dy);
    if (dist > 0.5) {
        const m = Math.min(player.speed, dist);
        player.x += dx / dist * m;
        player.y += dy / dist * m;
    }
}

/* ===== 描画 ===== */
function drawIdle() {
    ctx.fillStyle = "#050505";
    ctx.fillRect(0, 0, w, h);
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
    ctx.fillStyle = player.color;
    ctx.shadowBlur = 15;
    ctx.shadowColor = player.color;
    ctx.fill();
    ctx.shadowBlur = 0;
}

/* ===== ゲームオーバー ===== */
function gameOver() {
    isPlaying = false;
    isInputActive = false;
    player.moving = false;
    cancelAnimationFrame(animationId);
    const t = ((Date.now() - startTime) / 1000).toFixed(2);
    finalScore.textContent = `生存記録: ${t}秒`;
    gameOverScreen.style.display = "flex";
}

/* ===== ループ ===== */
function loop() {
    if (!isPlaying) return;

    ctx.fillStyle = "rgba(5,5,5,0.35)";
    ctx.fillRect(0, 0, w, h);

    const time = (Date.now() - startTime) / 1000;
    const diff = 1 + Math.floor(time / 8);
    scoreDisplay.textContent = `生存時間: ${time.toFixed(2)}秒`;

    movePlayer();

    ctx.beginPath();
    ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
    ctx.fillStyle = player.color;
    ctx.fill();

    if (Math.random() < 0.06 + diff * 0.02) spawnEnemy(diff);

    for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        e.x += e.vx;
        e.y += e.vy;
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
        ctx.fillStyle = "#ff3333";
        ctx.fill();
        if (Math.hypot(player.x - e.x, player.y - e.y) < player.radius + e.r) {
            gameOver();
            return;
        }
    }

    animationId = requestAnimationFrame(loop);
}

resize();
</script>
</body>
</html>
